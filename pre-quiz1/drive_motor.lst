CCS PCD C Compiler, Version 5.015, 5967               03-Nov-17 14:15

               Filename:   C:\Embed\pre-quiz1\drive_motor.lst

               ROM used:   2858 bytes (8%)
                           Largest free fragment is 27858
               RAM used:   196 (2%) at main() level
                           202 (2%) worst case
               Stack size: 128

*
0C00:  GOTO    1680
*
0C24:  GOTO    15A4
0C28:  GOTO    14E8
*
0C38:  GOTO    1546
*
0C74:  GOTO    15E2
*
0C94:  GOTO    132E
.................... #include "CONFIG_PIC24.H"   
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
0DFC:  CLR     32
0DFE:  MOV     #E08,W3
0E00:  ADD     W3,W0,W0
0E02:  TBLRDL.B[W0],W0L
0E04:  CLR.B   1
0E06:  RETURN  
0E08:  DATA    48,45,00
0E0A:  DATA    4C,4C,00
0E0C:  DATA    4F,32,00
0E0E:  DATA    00,00,00
0E10:  CLR     32
0E12:  MOV     #E1C,W3
0E14:  ADD     W3,W0,W0
0E16:  TBLRDL.B[W0],W0L
0E18:  CLR.B   1
0E1A:  RETURN  
0E1C:  DATA    48,45,00
0E1E:  DATA    4C,4C,00
0E20:  DATA    4F,00,00
0E22:  MOV     W5,[W15++]
0E24:  MOV     W6,[W15++]
0E26:  MOV     #8E,W1
0E28:  BCLR    W6.0
0E2A:  BTSS    W0.F
0E2C:  BRA     E34
0E2E:  BSET    W6.0
0E30:  NEG     W0,W0
0E32:  BRA     E34
0E34:  CP0     W0
0E36:  BRA     Z,E60
0E38:  BTSC    W0.F
0E3A:  BRA     E44
0E3C:  BCLR.B  42.0
0E3E:  RLC     W0,W0
0E40:  DEC     W1,W1
0E42:  BRA     E38
0E44:  SWAP    W1
0E46:  BCLR.B  42.0
0E48:  RRC     W1,W1
0E4A:  BCLR    W0.F
0E4C:  SWAP    W0
0E4E:  XOR.B   W0L,W1L,W1L
0E50:  AND.B   #0,W0L
0E52:  BTSC    W6.0
0E54:  BSET    W1.F
0E56:  BRA     E66
0E58:  MOV.B   W1L,W0L
0E5A:  BSET    W1.7
0E5C:  AND.B   #0,W1L
0E5E:  BRA     E66
0E60:  CLR     W0
0E62:  CLR     W1
0E64:  BRA     E66
0E66:  MOV     [--W15],W6
0E68:  MOV     [--W15],W5
0E6A:  RETURN  
0E6C:  MOV     W5,[W15++]
0E6E:  MOV     #C,W5
0E70:  REPEAT  #4
0E72:  MOV     [W5++],[W15++]
0E74:  MOV     W0,W4
0E76:  MOV     W1,W5
0E78:  MOV     W3,W7
0E7A:  MOV     W2,W6
0E7C:  BCLR.B  42.0
0E7E:  BCLR.B  42.1
0E80:  RLC     W1,W1
0E82:  SWAP    W1
0E84:  AND     #FF,W1
0E86:  CP0     W1
0E88:  BRA     Z,F20
0E8A:  BCLR.B  42.0
0E8C:  BCLR.B  42.1
0E8E:  RLC     W3,W3
0E90:  SWAP    W3
0E92:  AND     #FF,W3
0E94:  CP0     W3
0E96:  BRA     Z,F20
0E98:  ZE      W0,W0
0E9A:  ADD.B   W3L,W1L,W0L
0E9C:  BRA     C,EA6
0E9E:  SUB     #7F,W0
0EA0:  BRA     Z,F20
0EA2:  BRA     NC,F20
0EA4:  BRA     EAA
0EA6:  ADD.B   #81,W0L
0EA8:  BRA     C,F20
0EAA:  XOR     W5,W7,W10
0EAC:  BCLR.B  42.0
0EAE:  BCLR.B  42.1
0EB0:  AND     #FF,W5
0EB2:  BSET    W5.7
0EB4:  BCLR.B  42.0
0EB6:  AND     #FF,W7
0EB8:  BSET    W7.7
0EBA:  MUL.UU  W4,W6,W2
0EBC:  MUL.UU  W5,W6,W8
0EBE:  ADDC    W8,W3,W3
0EC0:  MOV     W9,W1
0EC2:  BTSC.B  42.0
0EC4:  INC     W1,W1
0EC6:  BCLR.B  42.0
0EC8:  MUL.UU  W7,W4,W8
0ECA:  ADDC    W8,W3,W3
0ECC:  ADDC    W9,W1,W1
0ECE:  MUL.UU  W5,W7,W8
0ED0:  ADDC    W8,W1,W1
0ED2:  INC     W0,W0
0ED4:  CP0     W1
0ED6:  BTSC.B  42.1
0ED8:  BRA     EDC
0EDA:  BRA     EE2
0EDC:  CP0     W3
0EDE:  BTSC.B  42.1
0EE0:  BRA     EEC
0EE2:  BTSC    W1.F
0EE4:  BRA     EEC
0EE6:  RLC     W3,W3
0EE8:  RLC     W1,W1
0EEA:  DEC     W0,W0
0EEC:  MOV     W1,W2
0EEE:  BCLR.B  42.0
0EF0:  BTSS    W3.7
0EF2:  BRA     F06
0EF4:  MOV     #FF00,W7
0EF6:  AND     W3,W7,W3
0EF8:  ADD     #100,W3
0EFA:  ADDC    W2,#0,W2
0EFC:  CP0     W2
0EFE:  BRA     NZ,F06
0F00:  CP0     W3
0F02:  BRA     NZ,F06
0F04:  INC     W0,W0
0F06:  SWAP    W0
0F08:  BCLR.B  42.0
0F0A:  BCLR.B  42.1
0F0C:  RRC     W0,W1
0F0E:  BTSC    W10.F
0F10:  BSET    W1.F
0F12:  BCLR    W2.F
0F14:  SWAP    W2
0F16:  XOR.B   W2L,W1L,W1L
0F18:  SWAP    W3
0F1A:  MOV.B   W3L,W2L
0F1C:  MOV     W2,W0
0F1E:  BRA     F26
0F20:  MOV     #0,W0
0F22:  MOV     #0,W1
0F24:  BRA     F26
0F26:  MOV     #14,W5
0F28:  REPEAT  #4
0F2A:  MOV     [--W15],[W5--]
0F2C:  MOV     [--W15],W5
0F2E:  RETURN  
0F30:  MOV     W5,[W15++]
0F32:  MOV     #C,W5
0F34:  REPEAT  #4
0F36:  MOV     [W5++],[W15++]
0F38:  CLR     W9
0F3A:  XOR     W1,W3,W9
0F3C:  MOV     W1,W6
0F3E:  MOV     W0,W5
0F40:  MOV     W3,W8
0F42:  MOV     W2,W7
0F44:  RLC     W1,W1
0F46:  SWAP    W1
0F48:  ZE      W1,W1
0F4A:  CP0     W1
0F4C:  BRA     Z,FEA
0F4E:  RLC     W3,W3
0F50:  SWAP    W3
0F52:  ZE      W3,W3
0F54:  CP0     W3
0F56:  BRA     Z,FEA
0F58:  CLR     W0
0F5A:  SUB.B   W1L,W3L,W0L
0F5C:  BRA     NC,F64
0F5E:  ADD.B   #7F,W0L
0F60:  BRA     C,FEA
0F62:  BRA     F6A
0F64:  SUB.B   #81,W0L
0F66:  BRA     NC,FEA
0F68:  BRA     Z,FEA
0F6A:  MOV     W5,W1
0F6C:  MOV     W6,W2
0F6E:  BSET    W2.7
0F70:  AND     #FF,W2
0F72:  AND     #FF,W8
0F74:  BSET    W8.7
0F76:  MOV     #19,W10
0F78:  CLR     W3
0F7A:  CLR     W4
0F7C:  SUB     W1,W7,W1
0F7E:  SUBB    W2,W8,W2
0F80:  BRA     N,F86
0F82:  BRA     C,F8C
0F84:  BRA     NZ,F8E
0F86:  ADD     W1,W7,W1
0F88:  ADDC    W2,W8,W2
0F8A:  BRA     F8E
0F8C:  BSET    W4.0
0F8E:  DEC     W10,W10
0F90:  BRA     Z,FA0
0F92:  BCLR.B  42.0
0F94:  RLC     W1,W1
0F96:  RLC     W2,W2
0F98:  BCLR.B  42.0
0F9A:  RLC     W4,W4
0F9C:  RLC     W3,W3
0F9E:  BRA     F7C
0FA0:  CLR     W10
0FA2:  BTSC    W3.8
0FA4:  BRA     FA8
0FA6:  BRA     FB4
0FA8:  BCLR.B  42.0
0FAA:  RRC     W3,W3
0FAC:  BCLR    W3.7
0FAE:  RRC     W4,W4
0FB0:  RLC     W10,W10
0FB2:  BRA     FB8
0FB4:  DEC     W0,W0
0FB6:  BRA     Z,FEA
0FB8:  BTSC    W10.F
0FBA:  BRA     NC,FC6
0FBC:  RLC     W1,W1
0FBE:  RLC     W2,W2
0FC0:  SUB     W1,W7,W1
0FC2:  SUBB    W2,W8,W2
0FC4:  BRA     NC,FD8
0FC6:  INC     W4,W4
0FC8:  BRA     NZ,FD8
0FCA:  INC     W3,W3
0FCC:  BRA     NZ,FD8
0FCE:  INC     W0,W0
0FD0:  BRA     Z,FEA
0FD2:  BRA     FD8
0FD4:  DEC     W0,W0
0FD6:  BRA     Z,FEA
0FD8:  SWAP    W0
0FDA:  RRC     W0,W1
0FDC:  BSET    W1.F
0FDE:  BTSS    W9.F
0FE0:  BCLR    W1.F
0FE2:  BCLR    W3.7
0FE4:  XOR.B   W3L,W1L,W1L
0FE6:  MOV     W4,W0
0FE8:  BRA     FF0
0FEA:  MOV     #0,W0
0FEC:  MOV     #0,W1
0FEE:  BRA     FF0
0FF0:  MOV     #14,W5
0FF2:  REPEAT  #4
0FF4:  MOV     [--W15],[W5--]
0FF6:  MOV     [--W15],W5
0FF8:  RETURN  
0FFA:  MOV     W5,[W15++]
0FFC:  MOV     #C,W5
0FFE:  REPEAT  #3
1000:  MOV     [W5++],[W15++]
1002:  CLR     W9
1004:  MOV     #8000,W8
1006:  BTSC.B  43.0
1008:  XOR     W8,W3,W3
100A:  CP0     W0
100C:  BRA     NZ,1014
100E:  MOV     #7FFF,W10
1010:  AND     W1,W10,W10
1012:  BTSS.B  42.1
1014:  MOV     W1,W10
1016:  XOR     W3,W10,W11
1018:  MOV     W1,W6
101A:  MOV     W3,W7
101C:  MOV     W3,W12
101E:  BCLR.B  42.1
1020:  BCLR.B  42.0
1022:  RLC     W6,W6
1024:  SWAP    W6
1026:  AND     #FF,W6
1028:  CP0     W6
102A:  BRA     Z,116E
102C:  BCLR.B  42.1
102E:  BCLR.B  42.0
1030:  RLC     W7,W7
1032:  SWAP    W7
1034:  AND     #FF,W7
1036:  CP0     W7
1038:  BRA     Z,1178
103A:  BCLR.B  42.1
103C:  BCLR.B  42.0
103E:  CP      W7,W6
1040:  BRA     Z,117A
1042:  BRA     N,118A
1044:  BCLR    W9.0
1046:  BSET    W9.1
1048:  SUB     W7,W6,W8
104A:  MOV     W7,W6
104C:  AND     #FF,W1
104E:  BSET    W1.7
1050:  AND     #FF,W3
1052:  BSET    W3.7
1054:  MOV     #28,W7
1056:  CP      W7,W8
1058:  BRA     N,107C
105A:  BCLR.B  42.1
105C:  BCLR.B  42.0
105E:  RRC     W1,W1
1060:  RRC     W0,W0
1062:  DEC     W8,W8
1064:  BRA     NZ,105A
1066:  BRA     1082
1068:  MOV     #28,W7
106A:  CP      W7,W8
106C:  BRA     N,1080
106E:  BCLR.B  42.1
1070:  BCLR.B  42.0
1072:  RRC     W3,W3
1074:  RRC     W2,W2
1076:  DEC     W8,W8
1078:  BRA     NZ,106E
107A:  BRA     109A
107C:  MOV     W2,W0
107E:  MOV     W3,W1
1080:  BRA     1108
1082:  BTSS    W11.F
1084:  BRA     10A8
1086:  BTSC    W9.4
1088:  MOV     W12,W11
108A:  NEG     W0,W0
108C:  BRA     Z,1092
108E:  COM.B   W1L,W1L
1090:  BRA     1094
1092:  NEG     W1,W1
1094:  BTSC    W9.4
1096:  BRA     10EE
1098:  BRA     10A8
109A:  BTSS    W11.F
109C:  BRA     10A8
109E:  NEG     W2,W2
10A0:  BRA     Z,10A6
10A2:  COM.B   W3L,W3L
10A4:  BRA     10A8
10A6:  NEG     W3,W3
10A8:  AND     #FF,W5
10AA:  BCLR.B  42.1
10AC:  BCLR.B  42.0
10AE:  ADD     W0,W2,W0
10B0:  ADDC.B  W1L,W3L,W1L
10B2:  BTSC.B  42.0
10B4:  BSET    W9.3
10B6:  BTSC    W9.0
10B8:  BRA     10CC
10BA:  BTSC    W9.1
10BC:  BRA     10C0
10BE:  BRA     10D6
10C0:  BTSC    W11.F
10C2:  BRA     10EE
10C4:  BTSC    W9.3
10C6:  BRA     111A
10C8:  BSET    W9.6
10CA:  BRA     1108
10CC:  BTSC    W11.F
10CE:  BRA     10EE
10D0:  BTSC    W9.3
10D2:  BRA     111A
10D4:  BRA     1108
10D6:  BCLR    W9.2
10D8:  BTSC    W11.F
10DA:  BRA     10E4
10DC:  MOV     W10,W11
10DE:  BTSC    W9.3
10E0:  BRA     111A
10E2:  BRA     1150
10E4:  BSET    W9.4
10E6:  XOR.B   #80,W1L
10E8:  BTSC    W1.7
10EA:  BRA     1086
10EC:  MOV     W10,W11
10EE:  AND     #FF,W1
10F0:  IOR      W0,  W1,W7
10F2:  BRA     Z,1108
10F4:  BTSC    W1.7
10F6:  BRA     1108
10F8:  BCLR.B  42.1
10FA:  BCLR.B  42.0
10FC:  RLC     W0,W0
10FE:  RLC     W1,W1
1100:  DEC     W6,W6
1102:  BTSC.B  42.1
1104:  BRA     1168
1106:  BRA     10F4
1108:  BTSC    W9.0
110A:  MOV     W10,W11
110C:  BTSC    W9.1
110E:  MOV     W12,W11
1110:  BTSS    W9.5
1112:  BRA     1148
1114:  BTSC    W10.F
1116:  BSET    W0.8
1118:  BRA     1150
111A:  BSET.B  42.0
111C:  RRC.B   W1L,W1L
111E:  RRC     W0,W0
1120:  BTSC.B  42.0
1122:  BSET    W9.5
1124:  INC     W6,W6
1126:  BRA     Z,1168
1128:  BTSS    W9.5
112A:  BRA     113C
112C:  INC     W0,W0
112E:  BRA     NZ,113C
1130:  INC.B   W1L,W1L
1132:  BRA     NZ,113C
1134:  RRC.B   W1L,W1L
1136:  RRC     W0,W0
1138:  INC     W6,W6
113A:  BRA     Z,1168
113C:  BTSC    W9.0
113E:  MOV     W10,W11
1140:  BTSC    W9.1
1142:  MOV     W12,W11
1144:  BTSC.B  42.1
1146:  BRA     1168
1148:  BTSC    W9.6
114A:  MOV     W10,W11
114C:  BTSC    W9.7
114E:  MOV     W12,W11
1150:  IOR      W0,  W1,W2
1152:  BRA     Z,119A
1154:  BCLR    W1.7
1156:  SWAP    W6
1158:  BCLR.B  42.1
115A:  BCLR.B  42.0
115C:  RRC     W6,W6
115E:  XOR     W6,W1,W1
1160:  BSET    W1.F
1162:  BTSS    W11.F
1164:  BCLR    W1.F
1166:  BRA     119A
1168:  MOV     #0,W0
116A:  MOV     #0,W1
116C:  BRA     119A
116E:  BTSC    W10.F
1170:  XOR     W8,W3,W3
1172:  MOV     W2,W0
1174:  MOV     W3,W1
1176:  BRA     119A
1178:  BRA     119A
117A:  AND     #FF,W3
117C:  BSET    W3.7
117E:  AND     #FF,W1
1180:  BSET    W1.7
1182:  BTSC    W11.F
1184:  BCLR    W3.7
1186:  BSET    W9.2
1188:  BRA     109A
118A:  SUB     W6,W7,W8
118C:  AND     #FF,W1
118E:  BSET    W1.7
1190:  AND     #FF,W3
1192:  BSET    W3.7
1194:  BCLR    W9.1
1196:  BSET    W9.0
1198:  BRA     1068
119A:  MOV     #12,W5
119C:  REPEAT  #3
119E:  MOV     [--W15],[W5--]
11A0:  MOV     [--W15],W5
11A2:  RETURN  
11A4:  MOV     W5,[W15++]
11A6:  MOV     W6,[W15++]
11A8:  MOV     W7,[W15++]
11AA:  XOR     W1,W3,W4
11AC:  BTSS    W4.F
11AE:  BRA     11BC
11B0:  BCLR.B  42.0
11B2:  BCLR.B  42.1
11B4:  BTSS    W1.F
11B6:  BRA     1204
11B8:  BSET.B  42.0
11BA:  BRA     1204
11BC:  MOV     W1,W4
11BE:  MOV     W0,W5
11C0:  MOV     W3,W6
11C2:  MOV     W2,W7
11C4:  RLC     W1,W1
11C6:  SWAP    W1
11C8:  RLC     W3,W3
11CA:  SWAP    W3
11CC:  SUB.B   W3L,W1L,W1L
11CE:  BRA     Z,11DA
11D0:  BTSS    W4.F
11D2:  BRA     1204
11D4:  MOV     #1,W0
11D6:  XOR.B   42
11D8:  BRA     1204
11DA:  MOV.B   W4L,W1L
11DC:  MOV.B   W6L,W3L
11DE:  BCLR    W1.7
11E0:  BCLR    W3.7
11E2:  SUB.B   W3L,W1L,W1L
11E4:  BRA     Z,11F0
11E6:  BTSS    W4.F
11E8:  BRA     1204
11EA:  MOV     #1,W0
11EC:  XOR.B   42
11EE:  BRA     1204
11F0:  SUB     W7,W5,W1
11F2:  BRA     Z,11FE
11F4:  BTSS    W4.F
11F6:  BRA     1204
11F8:  MOV     #1,W0
11FA:  XOR.B   42
11FC:  BRA     1204
11FE:  BCLR.B  42.0
1200:  BRA     1204
1202:  BRA     1204
1204:  MOV     [--W15],W7
1206:  MOV     [--W15],W6
1208:  MOV     [--W15],W5
120A:  RETURN  
120C:  MOV     W0,W2
120E:  MOV     W1,W3
1210:  MOV.B   W1L,W0L
1212:  SWAP    W0
1214:  BSET    W0.F
1216:  RLC     W1,W1
1218:  SWAP    W1
121A:  ZE      W1,W1
121C:  MOV     #8E,W4
121E:  SUB.B   W4L,W1L,W1L
1220:  BRA     Z,122E
1222:  CP0     W0
1224:  BRA     Z,122E
1226:  BCLR.B  42.0
1228:  RRC     W0,W0
122A:  DEC     W1,W1
122C:  BRA     NZ,1222
122E:  BTSS    W3.F
1230:  BRA     1236
1232:  NEG     W0,W0
1234:  BRA     1236
1236:  RETURN  
1238:  MOV     W5,[W15++]
123A:  MOV     #C,W5
123C:  REPEAT  #3
123E:  MOV     [W5++],[W15++]
1240:  BTSS    W0.F
1242:  BRA     125C
1244:  NEG     W0,W0
1246:  BSET    W4.8
1248:  BTSS    W4.F
124A:  BRA     125C
124C:  MOV     W0,[W15++]
124E:  MOV     #2D,W0
1250:  BTSC.B  223.1
1252:  BRA     1250
1254:  MOV     W0,224
1256:  MOV     [--W15],W0
1258:  BCLR    W4.8
125A:  DEC.B   0008
125C:  CLR     W5
125E:  MOV     W0,W7
1260:  MOV     W4,W9
1262:  BCLR    W4.F
1264:  CP0.B   W4L
1266:  BRA     NZ,1274
1268:  BTSC    W9.F
126A:  BRA     1270
126C:  MOV     #0,W5
126E:  BRA     128E
1270:  MOV     #0,W5
1272:  BRA     128E
1274:  SUB.B   W4L,#6,W5L
1276:  BRA     NC,128C
1278:  MOV     #30,W0
127A:  BTSS    W9.F
127C:  MOV     #20,W0
127E:  BTSC.B  223.1
1280:  BRA     127E
1282:  MOV     W0,224
1284:  DEC     W5,W5
1286:  BRA     NN,127E
1288:  MOV     #5,W5
128A:  BRA     128E
128C:  MOV     W4,W5
128E:  MOV     #6,W4
1290:  BTSC    W5.8
1292:  INC     W4,W4
1294:  BSET    W5.E
1296:  BTSC    W9.F
1298:  BSET    W5.F
129A:  MOV     #2710,W8
129C:  REPEAT  #11
129E:  DIV.U   W7,W8
12A0:  CALL    12E4
12A4:  MOV     W1,W7
12A6:  MOV     #3E8,W8
12A8:  REPEAT  #11
12AA:  DIV.U   W7,W8
12AC:  CALL    12E4
12B0:  MOV     W1,W7
12B2:  MOV     #64,W8
12B4:  REPEAT  #11
12B6:  DIV.U   W7,W8
12B8:  CALL    12E4
12BC:  MOV     W1,W7
12BE:  MOV     #A,W8
12C0:  REPEAT  #11
12C2:  DIV.U   W7,W8
12C4:  CALL    12E4
12C8:  BTSS    W9.8
12CA:  BRA     12D6
12CC:  MOV     #2D,W0
12CE:  BTSC.B  223.1
12D0:  BRA     12CE
12D2:  MOV     W0,224
12D4:  BCLR    W9.8
12D6:  MOV     #30,W0
12D8:  ADD.B   W1L,W0L,W0L
12DA:  MOV     W0,2A
12DC:  BTSC.B  223.1
12DE:  BRA     12DC
12E0:  MOV     W0,224
12E2:  BRA     1324
12E4:  MOV     #30,W6
12E6:  CP0     W0
12E8:  BRA     NZ,1306
12EA:  BTSS    W5.E
12EC:  BRA     131A
12EE:  DEC     W4,W4
12F0:  CP.B    W4L,W5L
12F2:  BRA     Z,12F8
12F4:  BTSC.B  42.0
12F6:  RETURN  
12F8:  CP0     W0
12FA:  BRA     NZ,1306
12FC:  BTSS    W5.E
12FE:  BRA     131A
1300:  BTSS    W5.F
1302:  MOV     #20,W6
1304:  BRA     131A
1306:  BCLR    W5.E
1308:  BTSS    W9.8
130A:  BRA     131A
130C:  MOV     W0,W10
130E:  MOV     #2D,W0
1310:  BTSC.B  223.1
1312:  BRA     1310
1314:  MOV     W0,224
1316:  BCLR    W9.8
1318:  MOV     W10,W0
131A:  ADD.B   W6L,W0L,W0L
131C:  BTSC.B  223.1
131E:  BRA     131C
1320:  MOV     W0,224
1322:  RETURN  
1324:  MOV     #12,W5
1326:  REPEAT  #3
1328:  MOV     [--W15],[W5--]
132A:  MOV     [--W15],W5
132C:  RETURN  
....................  
.................... #list 
....................  
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 1 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B6 
.................... //#pin_select INT2 = PIN_B5 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
....................  
.................... #pin_select OC1 = PIN_B2  // RP0  AX2 
.................... #pin_select IC1 = PIN_B4  // RP1  AX3 
.................... #pin_select IC2 = PIN_B5 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... //#include "BL_support.h" 
.................... /****************************************************************************/ 
.................... // o/p pins  LED 
.................... #define  LED0  PIN_A2 
.................... #define  LED1  PIN_A4 
.................... #define  LED2  PIN_B2 
.................... #define  LED3  PIN_B3 
....................  
.................... // i/p pins  PBSW 
.................... #define  SW0  PIN_B4 
.................... #define  SW1  PIN_B5 
.................... #define  SW2  PIN_B6 
.................... #define  SW3  PIN_B7 
....................  
.................... // ADC  or  i/o pins if not use ADC 
.................... #define  AX0  PIN_A0 
.................... #define  AX1  PIN_A1 
.................... #define  AX2  PIN_B0  // RP0 remap pin 
.................... #define  AX3  PIN_B1  // RP1 remap pin 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... #include "BL_Support.h" 
.................... /******************************************************************************/ 
.................... /* File:    BL_Support.h													  */ 
.................... /* Author:  Dr.Santi Nuratch												  */ 
.................... /*          Embedded Computing and Control Lab., INC-KMUTT 				      */ 
.................... /* Created on 22 September 2016, 13:14										  */ 
.................... /******************************************************************************/ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... #define START_DUTY 0 
.................... static void HardwareInit (void) ; 
.................... float target=0,currentPosition=0,e,int_e=0,p_e=0,u=0,pwm; 
.................... static int16u ip_b, c_a, c_b, direction, NewCap, OldCap, Interval; 
.................... int distance; 
.................... float tolerance = 3; 
.................... float Kp = 1000.0f; 
.................... float Ki = 1.0f; 
.................... float Kd = 70.0f; 
.................... int main (void) 
*
1680:  MOV     #2780,W15
1682:  MOV     #27FF,W0
1684:  MOV     W0,20
1686:  NOP     
1688:  BSET.B  81.7
168A:  MOV     #46,W0
168C:  MOV.B   W0L,742
168E:  MOV     #57,W0
1690:  MOV.B   W0L,742
1692:  BCLR.B  742.6
1694:  MOV     #63F,W0
1696:  MOV     W0,680
1698:  MOV     #504,W0
169A:  MOV     W0,68E
169C:  MOV     #3F0C,W0
169E:  MOV     W0,6A4
16A0:  MOV     #12,W0
16A2:  MOV     W0,6C2
16A4:  MOV     #300,W0
16A6:  MOV     W0,6CC
16A8:  MOV     #46,W0
16AA:  MOV.B   W0L,742
16AC:  MOV     #57,W0
16AE:  MOV.B   W0L,742
16B0:  BSET.B  742.6
16B2:  CLR     744
16B4:  MOV     #8000,W4
16B6:  MOV     W4,220
16B8:  MOV     #400,W4
16BA:  MOV     W4,222
16BC:  BSET.B  220.3
16BE:  MOV     #22,W4
16C0:  MOV     W4,228
16C2:  CLR     808
16C4:  CLR     80A
16C6:  CLR     80C
16C8:  CLR     80E
16CA:  CLR     814
16CC:  CLR     816
16CE:  CLR     818
16D0:  CLR     81A
16D2:  CLR     81C
16D4:  CLR     81E
16D6:  CLR     834
16D8:  MOV     #4040,W4
16DA:  MOV     W4,836
16DC:  CLR     838
16DE:  MOV     #447A,W4
16E0:  MOV     W4,83A
16E2:  CLR     83C
16E4:  MOV     #3F80,W4
16E6:  MOV     W4,83E
16E8:  CLR     840
16EA:  MOV     #428C,W4
16EC:  MOV     W4,842
16EE:  SETM    32C
16F0:  MOV     #84A,W4
16F2:  MOV     W4,806
16F4:  MOV     #1F32,W4
16F6:  MOV     W4,84A
16F8:  CLR     84C
16FA:  CLR     800
16FC:  CLR     824
16FE:  CLR     826
1700:  CLR     828
1702:  CLR     82A
1704:  CLR     82C
1706:  CLR     82E
1708:  CLR     830
.................... { 
.................... 	disable_interrupts(INTR_GLOBAL); 
170A:  BCLR.B  81.7
170C:  MOV     #E0,W4
170E:  MOV     W4,42
1710:  BSET.B  81.7
.................... 	clear_interrupt(INT_EXT0); 
1712:  BCLR.B  84.0
.................... 	enable_interrupts(INT_EXT0); 
1714:  BSET.B  94.0
.................... 	clear_interrupt(INT_EXT1); 
1716:  BCLR.B  86.4
.................... 	enable_interrupts(INT_EXT1); 
1718:  BSET.B  96.4
.................... 	HardwareInit(); 
171A:  CALL    1628
.................... 	enable_interrupts(INTR_GLOBAL); 
171E:  BCLR.B  81.7
1720:  CLR     42
1722:  BSET.B  81.7
.................... 	for(;;){ 
1724:  BRA     1724
....................  
....................  
.................... 	} 
.................... 	return 0; 
1726:  CLR     0
.................... } 
....................  
1728:  PWRSAV  #0
.................... static void HardwareInit (void) 
*
1628:  MOV     W5,[W15++]
.................... { 
.................... 	setup_adc_ports(NO_ANALOGS); 
162A:  SETM    32C
.................... 	//GPIO LED 0-3 : A2, A4, B2, B3 ; Sw 0-3 : B4, B5, B6, B7 
.................... 	set_tris_a (get_tris_a() & 0xffeb); // 1111 1111 1110 1011 A2, A4 o/p 
162C:  MOV     2C0,W5
162E:  MOV     #FFEB,W0
1630:  AND     W0,W5,W5
1632:  MOV     W5,2C0
.................... 	set_tris_b (get_tris_b() & 0xfff0); // 1111 1111 1111 0000 B2, B3 o/p 
1634:  MOV     2C8,W5
1636:  MOV     #FFF0,W0
1638:  AND     W0,W5,W5
163A:  MOV     W5,2C8
....................  
.................... 	set_compare_time(1, 0); 
163C:  CLR     182
.................... 	clear_interrupt(INT_TIMER2); 
163E:  BCLR.B  84.7
.................... 	setup_compare(1, COMPARE_PWM | COMPARE_TIMER2); 
1640:  MOV     #6,W4
1642:  MOV     W4,184
.................... 	set_timer2(0); 
1644:  CLR     106
.................... 	setup_timer2(TMR_INTERNAL | TMR_DIV_BY_256, 624); 
1646:  CLR     110
1648:  MOV     #270,W4
164A:  MOV     W4,10C
164C:  MOV     #8030,W4
164E:  MOV     W4,110
.................... 	set_pwm_duty(1,0); 
1650:  CLR     180
....................  
....................  
....................  
.................... 	clear_interrupt(INT_TIMER5); 
1652:  BCLR.B  87.4
.................... 	set_timer5(0); 
1654:  CLR     118
.................... 	setup_timer5(TMR_INTERNAL | TMR_DIV_BY_64,24); /////0.0001s 
1656:  CLR     120
1658:  MOV     #18,W4
165A:  MOV     W4,11C
165C:  MOV     #8020,W4
165E:  MOV     W4,120
.................... 	disable_interrupts(INT_TIMER5); 
1660:  BCLR.B  97.4
....................  
.................... 	setup_capture(1, CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER3); 
1662:  MOV     #1,W4
1664:  MOV     W4,142
.................... 	clear_interrupt(INT_IC1); 
1666:  BCLR.B  84.1
.................... 	enable_interrupts(INT_IC1); 
1668:  BSET.B  94.1
....................  
.................... 	setup_capture(2, CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER3); 
166A:  MOV     #1,W4
166C:  MOV     W4,146
.................... 	clear_interrupt(INT_IC2); 
166E:  BCLR.B  84.5
.................... 	enable_interrupts(INT_IC2); 
1670:  BSET.B  94.5
....................  
.................... 	set_timer3(0); 
1672:  CLR     10A
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_1, 65535); 
1674:  CLR     112
1676:  SETM    10E
1678:  MOV     #8000,W4
167A:  MOV     W4,112
....................  
....................  
.................... 	return; 
167C:  MOV     [--W15],W5
167E:  RETURN  
.................... } 
....................  
....................  
.................... #INT_TIMER5 
.................... void Pidcontrol_check(void){ 
*
132E:  PUSH    42
1330:  PUSH    36
1332:  PUSH    32
1334:  MOV     W0,[W15++]
1336:  MOV     #2,W0
1338:  REPEAT  #C
133A:  MOV     [W0++],[W15++]
.................... 	currentPosition = (7.5 * 22* (float)(distance) * 60)/(7 * 180 * 64); 
133C:  MOV     832,W0
133E:  CALL    E22
1342:  MOV     W0,W2
1344:  MOV     W1,W3
1346:  MOV     #0,W0
1348:  MOV     #4325,W1
134A:  CALL    E6C
134E:  MOV     W0,W5
1350:  MOV     W1,W6
1352:  MOV     W5,W0
1354:  MOV     W6,W1
1356:  MOV     #0,W2
1358:  MOV     #4270,W3
135A:  CALL    E6C
135E:  MOV     W0,W5
1360:  MOV     W1,W6
1362:  MOV     W5,W0
1364:  MOV     W6,W1
1366:  MOV     #8000,W2
1368:  MOV     #479D,W3
136A:  CALL    F30
136E:  MOV     W0,80C
1370:  MOV     W1,80E
....................  
.................... 	e = target - currentPosition; 
1372:  BSET.B  43.0
1374:  MOV     808,W0
1376:  MOV     80A,W1
1378:  MOV     80C,W2
137A:  MOV     80E,W3
137C:  CALL    FFA
1380:  MOV     W0,810
1382:  MOV     W1,812
.................... 	 
.................... 	 
.................... 	int_e = int_e + e; 
1384:  BCLR.B  43.0
1386:  MOV     814,W0
1388:  MOV     816,W1
138A:  MOV     810,W2
138C:  MOV     812,W3
138E:  CALL    FFA
1392:  MOV     W0,814
1394:  MOV     W1,816
.................... 	u = Kp*e + Ki*int_e + Kd*(e-p_e); 
1396:  MOV     838,W0
1398:  MOV     83A,W1
139A:  MOV     810,W2
139C:  MOV     812,W3
139E:  CALL    E6C
13A2:  MOV     W0,W5
13A4:  MOV     W1,W6
13A6:  MOV     83C,W0
13A8:  MOV     83E,W1
13AA:  MOV     814,W2
13AC:  MOV     816,W3
13AE:  CALL    E6C
13B2:  BCLR.B  43.0
13B4:  MOV     W0,W2
13B6:  MOV     W1,W3
13B8:  MOV     W5,W0
13BA:  MOV     W6,W1
13BC:  CALL    FFA
13C0:  MOV     W0,W5
13C2:  MOV     W1,W6
13C4:  BSET.B  43.0
13C6:  MOV     810,W0
13C8:  MOV     812,W1
13CA:  MOV     818,W2
13CC:  MOV     81A,W3
13CE:  CALL    FFA
13D2:  MOV     W0,W2
13D4:  MOV     W1,W3
13D6:  MOV     840,W0
13D8:  MOV     842,W1
13DA:  CALL    E6C
13DE:  BCLR.B  43.0
13E0:  MOV     W0,W2
13E2:  MOV     W1,W3
13E4:  MOV     W5,W0
13E6:  MOV     W6,W1
13E8:  CALL    FFA
13EC:  MOV     W0,81C
13EE:  MOV     W1,81E
.................... 	p_e = e; 
13F0:  PUSH    810
13F2:  POP     818
13F4:  PUSH    812
13F6:  POP     81A
.................... 	 
.................... 	 
.................... 	if(abs(e) > tolerance){ 
13F8:  MOV     810,W0
13FA:  MOV     812,W1
13FC:  BCLR    W1.F
13FE:  MOV     W0,W5
1400:  MOV     W1,W6
1402:  MOV     834,W0
1404:  MOV     836,W1
1406:  MOV     W5,W2
1408:  MOV     W6,W3
140A:  CALL    11A4
140E:  BRA     NC,141C
.................... 		pwm = abs(u); 
1410:  MOV     81C,W0
1412:  MOV     81E,W1
1414:  BCLR    W1.F
1416:  MOV     W0,820
1418:  MOV     W1,822
.................... 	} 
141A:  BRA     1424
.................... 	else { 
.................... 		pwm = 0; 
141C:  CLR     820
141E:  CLR     822
.................... 		set_pwm_duty(1,0); 
1420:  CLR     180
.................... 		disable_interrupts(INT_TIMER5); 
1422:  BCLR.B  97.4
.................... 	} 
.................... 	printf("%d\n", (int16)e); 
1424:  MOV     810,W0
1426:  MOV     812,W1
1428:  CALL    120C
142C:  MOV     W0,W5
142E:  MOV     W5,W0
1430:  MOV     #0,W4
1432:  CALL    1238
1436:  BTSC.B  223.1
1438:  BRA     1436
143A:  MOV     #A,W4
143C:  MOV     W4,224
.................... 	if( u > 0){ 
143E:  MOV     #0,W0
1440:  MOV     #0,W1
1442:  MOV     81C,W2
1444:  MOV     81E,W3
1446:  CALL    11A4
144A:  BRA     NC,1492
.................... 		output_high(PIN_B0); 
144C:  BSET.B  2CC.0
.................... 		if (pwm > 200000){ pwm = 200000;} 
144E:  MOV     #5000,W0
1450:  MOV     #4843,W1
1452:  MOV     820,W2
1454:  MOV     822,W3
1456:  CALL    11A4
145A:  BRA     NC,1464
145C:  MOV     #5000,W4
145E:  MOV     W4,820
1460:  MOV     #4843,W4
1462:  MOV     W4,822
.................... 		pwm = pwm *800 / 200000; 
1464:  MOV     820,W0
1466:  MOV     822,W1
1468:  MOV     #0,W2
146A:  MOV     #4448,W3
146C:  CALL    E6C
1470:  MOV     W0,W5
1472:  MOV     W1,W6
1474:  MOV     W5,W0
1476:  MOV     W6,W1
1478:  MOV     #5000,W2
147A:  MOV     #4843,W3
147C:  CALL    F30
1480:  MOV     W0,820
1482:  MOV     W1,822
.................... 		set_pwm_duty(1,(int16u)pwm); 
1484:  MOV     820,W0
1486:  MOV     822,W1
1488:  CALL    120C
148C:  MOV     W0,W5
148E:  MOV     W5,180
.................... 	} 
1490:  BRA     14D6
.................... 	else{ 
.................... 		output_high(PIN_B1); 
1492:  BSET.B  2CC.1
.................... 		if (pwm > 100000){ pwm = 100000;} 
1494:  MOV     #5000,W0
1496:  MOV     #47C3,W1
1498:  MOV     820,W2
149A:  MOV     822,W3
149C:  CALL    11A4
14A0:  BRA     NC,14AA
14A2:  MOV     #5000,W4
14A4:  MOV     W4,820
14A6:  MOV     #47C3,W4
14A8:  MOV     W4,822
.................... 		pwm = pwm *800 / 100000; 
14AA:  MOV     820,W0
14AC:  MOV     822,W1
14AE:  MOV     #0,W2
14B0:  MOV     #4448,W3
14B2:  CALL    E6C
14B6:  MOV     W0,W5
14B8:  MOV     W1,W6
14BA:  MOV     W5,W0
14BC:  MOV     W6,W1
14BE:  MOV     #5000,W2
14C0:  MOV     #47C3,W3
14C2:  CALL    F30
14C6:  MOV     W0,820
14C8:  MOV     W1,822
.................... 		set_pwm_duty(1,(int16u)pwm); 
14CA:  MOV     820,W0
14CC:  MOV     822,W1
14CE:  CALL    120C
14D2:  MOV     W0,W5
14D4:  MOV     W5,180
.................... 	} 
.................... 	return; 
.................... }	 
....................  
....................  
14D6:  BCLR.B  87.4
14D8:  MOV     #1A,W0
14DA:  REPEAT  #C
14DC:  MOV     [--W15],[W0--]
14DE:  MOV     [--W15],W0
14E0:  POP     32
14E2:  POP     36
14E4:  POP     42
14E6:  RETFIE  
.................... #INT_IC1 
.................... void IC1ISR (void){ 
14E8:  PUSH    42
14EA:  PUSH    36
14EC:  PUSH    32
14EE:  MOV     W0,[W15++]
14F0:  MOV     #2,W0
14F2:  REPEAT  #C
14F4:  MOV     [W0++],[W15++]
.................... 	ip_b = input_b(); 
14F6:  PUSH    2CA
14F8:  POP     824
.................... 	NewCap = get_capture(1); 
14FA:  PUSH    140
14FC:  POP     82C
.................... 	Interval = NewCap - OldCap; 
14FE:  MOV     82C,W4
1500:  MOV     82E,W3
1502:  SUB     W4,W3,W0
1504:  MOV     W0,830
.................... 	OldCap = NewCap; 
1506:  PUSH    82C
1508:  POP     82E
.................... 	c_a = (ip_b & 0x10) >> 4; 
150A:  MOV     824,W0
150C:  AND     W0,#10,W5
150E:  LSR     W5,#4,W0
1510:  MOV     W0,826
.................... 	c_b = (ip_b & 0x20) >> 5; 
1512:  MOV     824,W5
1514:  AND     #20,W5
1516:  LSR     W5,#5,W0
1518:  MOV     W0,828
.................... 	if(c_a == c_b){ 
151A:  MOV     826,W0
151C:  CP      828
151E:  BRA     NZ,152A
.................... 		direction = 0; 
1520:  CLR     82A
.................... 		distance -=1; 
1522:  MOV     832,W4
1524:  SUB     W4,#1,W0
1526:  MOV     W0,832
.................... 	} 
1528:  BRA     1534
.................... 	else{ 
.................... 		direction = 1; 
152A:  MOV     #1,W4
152C:  MOV     W4,82A
.................... 		distance +=1; 
152E:  MOV     832,W4
1530:  ADD     W4,#1,W4
1532:  MOV     W4,832
.................... 	} 
.................... 	// printf("a\n"); 
....................  
.................... 	return; 
.................... } 
....................  
....................  
....................  
1534:  BCLR.B  84.1
1536:  MOV     #1A,W0
1538:  REPEAT  #C
153A:  MOV     [--W15],[W0--]
153C:  MOV     [--W15],W0
153E:  POP     32
1540:  POP     36
1542:  POP     42
1544:  RETFIE  
.................... #INT_IC2 
.................... void IC2ISR (void){ 
1546:  PUSH    42
1548:  PUSH    36
154A:  PUSH    32
154C:  MOV     W0,[W15++]
154E:  MOV     #2,W0
1550:  REPEAT  #C
1552:  MOV     [W0++],[W15++]
.................... 	ip_b = input_b(); 
1554:  PUSH    2CA
1556:  POP     824
.................... 	NewCap = get_capture(2); 
1558:  PUSH    144
155A:  POP     82C
.................... 	Interval = NewCap - OldCap; 
155C:  MOV     82C,W4
155E:  MOV     82E,W3
1560:  SUB     W4,W3,W0
1562:  MOV     W0,830
.................... 	OldCap = NewCap; 
1564:  PUSH    82C
1566:  POP     82E
.................... 	c_a = (ip_b & 0x10) >> 4; 
1568:  MOV     824,W0
156A:  AND     W0,#10,W5
156C:  LSR     W5,#4,W0
156E:  MOV     W0,826
.................... 	c_b = (ip_b & 0x20) >> 5; 
1570:  MOV     824,W5
1572:  AND     #20,W5
1574:  LSR     W5,#5,W0
1576:  MOV     W0,828
.................... 	if(c_a != c_b){ 
1578:  MOV     826,W0
157A:  CP      828
157C:  BRA     Z,1588
.................... 		direction = 0; 
157E:  CLR     82A
.................... 		distance -=1; 
1580:  MOV     832,W4
1582:  SUB     W4,#1,W0
1584:  MOV     W0,832
.................... 	} 
1586:  BRA     1592
.................... 	else{ 
.................... 		direction = 1; 
1588:  MOV     #1,W4
158A:  MOV     W4,82A
.................... 		distance+=1; 
158C:  MOV     832,W4
158E:  ADD     W4,#1,W4
1590:  MOV     W4,832
.................... 	} 
.................... 	// printf("b\n"); 
.................... 	return; 
.................... } 
....................  
1592:  BCLR.B  84.5
1594:  MOV     #1A,W0
1596:  REPEAT  #C
1598:  MOV     [--W15],[W0--]
159A:  MOV     [--W15],W0
159C:  POP     32
159E:  POP     36
15A0:  POP     42
15A2:  RETFIE  
.................... #INT_EXT0 
.................... void set_target(void){ 
15A4:  PUSH    42
15A6:  PUSH    36
15A8:  PUSH    32
15AA:  MOV     W0,[W15++]
15AC:  MOV     #2,W0
15AE:  REPEAT  #C
15B0:  MOV     [W0++],[W15++]
.................... 	target = 0 ; 
15B2:  CLR     808
15B4:  CLR     80A
.................... 	enable_interrupts(INT_TIMER5); 
15B6:  BSET.B  97.4
.................... 	printf("HELLO2"); 
15B8:  MOV     #0,W1
15BA:  MOV     W1,W0
15BC:  CLR.B   1
15BE:  CALL    DFC
15C2:  INC     W1,W1
15C4:  BTSC.B  223.1
15C6:  BRA     15C4
15C8:  MOV     W0,224
15CA:  MOV     #5,W0
15CC:  CPSGT   W1,W0
15CE:  BRA     15BA
....................  
.................... } 
15D0:  BCLR.B  84.0
15D2:  MOV     #1A,W0
15D4:  REPEAT  #C
15D6:  MOV     [--W15],[W0--]
15D8:  MOV     [--W15],W0
15DA:  POP     32
15DC:  POP     36
15DE:  POP     42
15E0:  RETFIE  
.................... #INT_EXT1 
.................... void set_target_2(void){ 
15E2:  PUSH    42
15E4:  PUSH    36
15E6:  PUSH    32
15E8:  MOV     W0,[W15++]
15EA:  MOV     #2,W0
15EC:  REPEAT  #C
15EE:  MOV     [W0++],[W15++]
.................... 	target = 1500; 
15F0:  MOV     #8000,W4
15F2:  MOV     W4,808
15F4:  MOV     #44BB,W4
15F6:  MOV     W4,80A
.................... 	enable_interrupts(INT_TIMER5); 
15F8:  BSET.B  97.4
.................... 	printf("HELLO"); 
15FA:  MOV     #0,W1
15FC:  MOV     W1,W0
15FE:  CLR.B   1
1600:  CALL    E10
1604:  INC     W1,W1
1606:  BTSC.B  223.1
1608:  BRA     1606
160A:  MOV     W0,224
160C:  MOV     #4,W0
160E:  CPSGT   W1,W0
1610:  BRA     15FC
.................... 	output_low(LED0); 
1612:  BCLR.B  2C4.2
.................... 	output_low(LED1); 
1614:  BCLR.B  2C4.4
1616:  BCLR.B  86.4
1618:  MOV     #1A,W0
161A:  REPEAT  #C
161C:  MOV     [--W15],[W0--]
161E:  MOV     [--W15],W0
1620:  POP     32
1622:  POP     36
1624:  POP     42
1626:  RETFIE  
.................... } 

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9C7   NOPR NOALTI2C1 NOIOL1WAY OSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
